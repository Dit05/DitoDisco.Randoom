using System;


namespace DitoDisco.Randoom {

    /// <summary>
    /// Base class for ((pseudo)random) generators. The rationale for this is that generators can simply implement bit generation, and everything else works using base class methods that call <see cref="NextBit"/>. <see cref="System.Random"/>'s approach is better suited for conventional (serious) random number generators, but this module is not the place for those.
    /// </summary>
    public abstract class BitGenerator {

        /// <summary>
        /// Returns true or false.
        /// </summary>
        public abstract bool NextBit();


        // Floating point number generation
        // We OR generated bits into the mantissa (least significant bits), then subtract 1 to go from [1; 2[ to [0; 1[.

        /// <summary>
        /// Returns a double-precision floating point number from generated bits that is at least 0 and less than 1.
        /// </summary>
        public double NextDouble() => BitConverter.Int64BitsToDouble( (long)NextUInt64WithBits(53) | BitConverter.DoubleToInt64Bits(1.0) ) - 1.0; // Double-precision floats use 53 bits of mantissa.

        /// <summary>
        /// Like <see cref="NextDouble"/>, but generates a single-precision floating point number. Prefer calling this over casting the result of <see cref="NextDouble"/>, because this calls <see cref="NextBit"/> fewer times.
        /// </summary>
        public float NextSingle() => BitConverter.Int32BitsToSingle( (int)NextUInt64WithBits(24) | BitConverter.SingleToInt32Bits(1.0f) ) - 1.0f; // Single-precision floats use 24 bits of mantissa.



        // Integer generation

        /// <summary>
        /// Fills the provided span with generated bytes.
        /// </summary>
        public void NextBytes(Span<byte> buffer) {
            for(int i = 0; i < buffer.Length; i++) {
                buffer[i] = NextByte();
            }
        }

        /// <summary>
        /// Generates a byte, where each bit is the output of <see cref="NextBit"/>.
        /// </summary>
        public byte NextByte() {
            return (byte)(
                (NextBit() ? (1 << 0) : 0) |
                (NextBit() ? (1 << 1) : 0) |
                (NextBit() ? (1 << 2) : 0) |
                (NextBit() ? (1 << 3) : 0) |
                (NextBit() ? (1 << 4) : 0) |
                (NextBit() ? (1 << 5) : 0) |
                (NextBit() ? (1 << 6) : 0) |
                (NextBit() ? (1 << 7) : 0)
            );
        }


        /// <summary>
        /// Returns a pseudorandom 64-bit unsigned integer with the first <paramref name="bitCount"/> bits generated.
        /// </summary>
        public ulong NextUInt64WithBits(int bitCount) {
            if(bitCount < 0 || bitCount > sizeof(ulong) * 8) throw new ArgumentOutOfRangeException(nameof(bitCount));

            ulong num = 0;
            for(int i = 0; i < bitCount; i++) {
                if(NextBit()) num |= 1ul << i;
            }

            return num;
        }


        /// <summary>
        /// Generates a <see cref="UInt64"/> between 0 and <see cref="UInt64.MaxValue"/>, inclusive.
        /// </summary>
        public ulong NextUInt64() => NextUInt64WithBits(sizeof(ulong) * 8);

        /// <summary>
        /// Generates a <see cref="UInt64"/> that is at least 0 and smaller than <paramref name="upperBound"/>, unless the upper bound is 0, then 0 is returned.
        /// </summary>
        /// <param name="upperBound">Exclusive upper bound of the value.</param>
        public ulong NextUInt64(ulong upperBound) {
            if(upperBound < 0) throw new ArgumentOutOfRangeException(nameof(upperBound), "Upper bound must be at least 0.");
            if(upperBound == 0) return 0;

            //int bitCount = Math.ILogB(maxValue) + 1; // This is not in .NET Standard 2.1
            int bitCount = 0;

            ulong maxValueCopy = upperBound;
            while(maxValueCopy > 0) {
                maxValueCopy >>= 1;
                bitCount++;
            }

            int safetyCounter = 256; // This should not be too high, since some generators may never generate appropriate bits.
            while(safetyCounter-- > 0) {
                ulong possibleValue = NextUInt64WithBits(bitCount);

                if(possibleValue < upperBound) return possibleValue;
            }

            // Give up and just return the value in the center
            return upperBound / 2;
        }

        /// <summary>
        /// Generates a <see cref="UInt64"/> that is at least <paramref name="lowerBound"/> but less than <paramref name="upperBound"/>, unless the lower and upper bounds are equal, then that value is returned.
        /// </summary>
        /// <param name="lowerBound">Inclusive lower bound of the generated value.</param>
        /// <param name="upperBound">Exclusive upper bound of the generated value.</param>
        public ulong NextUInt64(ulong lowerBound, ulong upperBound) {
            if(upperBound < lowerBound) throw new ArgumentOutOfRangeException(nameof(upperBound), "Upper bound must not be smaller than the lower bound.");
            if(upperBound == lowerBound) return lowerBound;

            return lowerBound + NextUInt64(upperBound - lowerBound);
        }


        /// <summary>
        /// Generates a <see cref="Int32"/> between 0 and <see cref="Int32.MaxValue"/>, inclusive.
        /// </summary>
        public int Next() => (int)NextUInt64WithBits(sizeof(int) * 8 - 1);

        /// <summary>
        /// Generates a <see cref="Int32"/> that is at least 0 and less than <paramref name="upperBound"/>.
        /// </summary>
        /// <param name="upperBound">Exclusive upper bound of the value.</param>
        public int Next(int upperBound) {
            if(upperBound < 0) throw new ArgumentOutOfRangeException(nameof(upperBound), "Upper bound cannot be less than 0.");
            return (int)NextUInt64((ulong)upperBound);
        }

        /// <summary>
        /// Generates a <see cref="Int32"/> that is at least <paramref name="lowerBound"/> but less than <paramref name="upperBound"/>, unless the lower and upper bounds are equal.
        /// </summary>
        /// <param name="lowerBound">Inclusive lower bound of the value.</param>
        /// <param name="upperBound">Exclusive upper bound of the value.</param>
        public int Next(int lowerBound, int upperBound) {
            if(upperBound < lowerBound) throw new ArgumentOutOfRangeException(nameof(upperBound), "Upper bound must not be smaller than the lower bound.");

            return lowerBound + Next(upperBound - lowerBound);
        }



        /// <summary>
        /// Generates a <see cref="Int64"/> between 0 and <see cref="Int64.MaxValue"/>, inclusive.
        /// </summary>
        public long NextInt64() => (long)NextUInt64WithBits(sizeof(ulong) * 8 - 1);


        /// <summary>
        /// Generates a <see cref="Int64"/> that is at least 0 and smaller than <paramref name="upperBound"/>, unless the upper bound is 0, then 0 is returned.
        /// </summary>
        /// <param name="upperBound">Exclusive upper bound of the value.</param>
        public long NextInt64(long upperBound) => (long)NextUInt64((ulong)upperBound);


        /// <summary>
        /// Generates a <see cref="Int64"/> that is at least <paramref name="lowerBound"/> but less than <paramref name="upperBound"/>, unless the lower and upper bounds are equal, then that value is returned.
        /// </summary>
        /// <param name="lowerBound">Inclusive lower bound of the value.</param>
        /// <param name="upperBound">Exclusive upper bound of the value.</param>
        public long NextInt64(long lowerBound, long upperBound) {
            if(upperBound < lowerBound) throw new ArgumentOutOfRangeException(nameof(upperBound), "Upper bound must not be smaller than the lower bound.");
            if(upperBound == lowerBound) return lowerBound;

            return lowerBound + NextInt64(upperBound - lowerBound);
        }


    }

}
